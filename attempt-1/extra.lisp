(in-package #:attempt-1)




(defun doit2 ()
  (let* ((dll (dll:make-list))
         ;; Keep track of these nodes for now.
         (cur-0 nil)
         (cur-1 nil))
    (flet ((emit-dll (edl msg)
             (format t "dlist: ~A~% HEAD~%~{  ~(~S~)~%~} HORIZON~%~%"
                     msg
                     (dll:list-values edl))))

      ;; TODO: Cursors should be held in a hash table for easy access in quack.

      (emit-dll dll "Empty")

      (setf cur-0 (dll:insert dll '(0 . :cursor) :where :before))
      (emit-dll dll "Insert before :head Cursor-0")

      (setf cur-1 (dll:insert dll '(1 . :cursor) :where :after
                                                 :target (dll:tail dll)))
      (emit-dll dll "Insert after :tail Cursor-1")

      (dll:insert dll :0-zero :where :before :target cur-0)
      (emit-dll dll "Queue before Cursor-0: :0-zero")

      (dll:insert dll :0-one :where :before :target cur-0)
      (emit-dll dll "Queue before Cursor-0: :0-one")

      (dll:insert dll :1-zero :where :before :target cur-1)
      (emit-dll dll "Queue before Cursor-1: :1-zero")

      (dll:insert dll :1-one :where :before :target cur-1)
      (emit-dll dll "Queue before Cursor-1: :1-one")

      (dll:insert dll :1-two :where :before :target cur-1)
      (emit-dll dll "Queue before Cursor-1: :1-two")

      (format t "There are ~A elements in the dll.~%~%" (dll:length dll))

      (format t "Processing dll like a queue from head to horizon...~%")
      (format t "  AT HEAD~%")
      (loop :until (zerop (dll:length dll))
            :for node = (dll:head dll)
            :for idx :from 0
            :do (dll:delete dll (dll:head dll))
                (format t "   Processed node: [~A]: ~(~S~)~%" idx node))
      (format t "  AT HORIZON~%")


      )))




;; HEAD: (_: future event horizon )
;; [00]: _
;; HORIZON

;; Run a function to push stuff onto the quack.

;; HEAD: (_: future event horizon)

;; + [P0] _prologue
;; + [Y0] op/set-mutation-phase 1
;; + [Y1] op/compute-physics (_A)   <----------------------------- probable fb
;; + [Y2] op/compute-and-emit-collisions (_A)
;; + [Y3] op/phase/physics-update (_A)
;; + [Y4] op/phase/update (_A)
;; + [Y5] op/phase/render (_A)
;; --------------------------------------- gamedev stable fb



;; Begin Mutation Phase 1

;; op/make-prefab-instance <foobar>
;; op/make-prefab-instance <bar>
;; _1_MakePrefab
;; op/reparent foobar qux
;; op/reparent bar qux
;; _1_Parenting
;; op/enable <actor 2>
;; op/disable <comp1>
;; op/deregister <comp1>
;; op/disable <comp2>
;; op/deregister <comp2>
;; _1_Attach/Detach/Enable/Disable

;; Status flags: destroy-requested-p reap-p
;; op/destroy <actor1> [op/destroy sets the reap-p flag in status register]
;; op/destroy <actor2>
;; op/reap-souls purgatory
;; _1_Destroy

;; End Mutation Phase 1


;; Begin Mutation Phase 2
;; _2_MakePrefab
;; _2_Parenting
;; _2_Attach/Detach/Enable/Disable
;; op/%destroy <actor3>
;; op/%destroy <actor1>
;; op/%destroy <actor2>
;; op/reap-souls purgatory [if destroy-requested-p then clear it, set reap-p]
;; _2_Destroy
;; End Mutation Phase 2

;; Begin Mutation Phase 3
;; _3_MakePrefab
;; _3_Parenting
;; _3_Attach/Detach/Enable/Disable
;; op/%%destroy <actor3-comp1>
;; op/%%destroy <actor3-comp2>
;; op/%%destroy <actor3>
;; op/%%destroy <actor1-comp1>
;; op/%%destroy <actor1>
;; op/%%destroy <actor2-comp1>
;; op/%%destroy <actor2>
;; op/reap-souls purgatory [if destroy-requested-p then clear it, set reap-p]
;; _3_Destroy
;; End Mutation Phase 3


;; Begin Mutation Phase 4
;; _4_MakePrefab
;; _4_Parenting
;; _4_Attach/Detach/Enable/Disable
;; op/reap-souls purgatory [if not destroy-requested-p then push ops & bundles & op/actually..., set reap-p]
;; _4_Destroy
;; End Mutation Phase 4


;; Begin Mutation Phase 5
;; _5_MakePrefab
;; _5_Parenting
;; [The below is generated by op/reap-souls]
;; op/deregister purgatory
;; op/compute-and-emit-deregistered-collision
;; op/disable purgatory
;; op/detach purgatory
;; _5_Attach/Detach/Enable/Disable
;; op/actually-reap-and-destroy purgatory [clear destroy-requested-p, clear reap-p]
;; _5_Destroy
;; End Mutation Phase 5

;; Begin Mutation Phase 6
;; op/make-prefab-instance <explosion>
;; _6_MakePrefab
;; _6_Parenting
;; _6_Attach/Detach/Enable/Disable
;; _6_Destroy
;; End Mutation Phase 6


;; and so on...

;; + [Y6] op/garbage-collect
;; + [Y7] req/recompilations (_B)
;; + [Y8] _B
;; ------------------------------------------------ actual fb
;; [00] _
;; HORIZON
















;; HEAD: (_: future, _B: end of frame, _A: end of user code)
;; - [Y0] req/compute-physics (_A) <nil requests>
;; - [Y1] req/compute-and-emit-collisions (_A) <nil requests>
;; - [Y2] req/phase/physics-update (_A) <generated X requests>
;; [Y3] req/phase/update (_A)
;; [Y4] req/phase/render (_A)
;; + [X0] req/make-prefab-instance (_C)
;; + [X1] _C
;; + [X2] req/enable <actor 0> (_D)
;; + [X3] _D
;; + [X4] req/disable <actor 0> (_E)
;; + [X5] _E
;; [Y5] _A
;; [Y6] req/recompilations (_B)
;; [Y7] _B
;; [00] _
;; HORIZON

;; HEAD: (_: future, _B: end of frame, _A: end of user code)
;; - [Y3] req/phase/update (_A) <generated W requests>
;; [Y4] req/phase/render (_A)
;; [X0] req/make-prefab-instance (_C)
;; [X1] _C
;; [X2] req/enable <actor 0> (_D)
;; [X3] _D
;; [X4] req/disable <actor 0> (_E)
;; [X5] _E
;; + [W0] req/make-component <comp 0> (_F)
;; + [W1] _F
;; + [W2] req/attach <actor 0 | comp 0> (_G)
;; + [W3] _G
;; [Y5] _A
;; [Y6] req/recompilations (_B)
;; [Y7] _B
;; [00] _
;; HORIZON

;; BR means "Beta reduction"
;; Vocabulary: "Frame context" is the ( ... ) list after HEAD.
;;             Any request can access.
;; Vocabulary: "Request context" is the ( ... ) for a _request_
;;             A set of cursors relavent to this specific request, provided by
;;             the maker of the request.
;; NOTE: A request can know the frame context and the current request context.
;; NOTE: This DOES preserve the _actual_ ordering of the requests as found in
;; the user's code.
;; =======================
;; HEAD: (_: future ...)
;; [X0] req/make-prefab-instance P0 (_C_pre, C_v:bind, _C_default, _C_post, _C)
;; [X1] _C_pre
;; [X2] _C_v:bind
;; [X3] _C_default
;; [X4] _C_post
;; [X5] _C
;; [Y0] req/make-prefab-instance P1 (_C_pre, C_v:bind, _C_default, _C_post, _C)
;; [Y1] _C_pre
;; [Y2] _C_v:bind
;; [Y3] _C_default
;; [Y4] _C_post
;; [5] _C
;; [00] _
;; HORIZON
;; =======================
;;
;; =======================
;; HEAD: (_: future ...)
;; - [X0] req/make-prefab-instance (_C)
;; [X1] _C
;; [00] _
;; HORIZON
;; =======================

;; NOTE:
;; When the phase-order can be specified by the user, there are some special
;; V only symbols which represent actions of the engine that we do not want
;; to export to the user. So, here V:BIND means "The point at which the physical
;; assignment of the reference of the component into the actor happens." The
;; other keywords simply represent phases the user can hook into. These
;; V:BIND, etc keywords must NOT be overridable by the user. We can write
;; macros to help with the management of these keywords.
;;
;; (adjust-phase-order 'attach '(:pre v:bind :default :post))

;; HEAD: (_: future, _B: end of frame, _A: end of user code)
;; - [Y4] req/phase/render (_A) <generated no requests>
;; - [X0] req/make-prefab-instance <prefab 1> <parent 1> (_C) <gen. V request>

;; + [V0] req/make-actor <actor 1> () <- This means cannot generate BR requests!
;; + [V1] req/make-component <comp 1> (_H)
;; + [V2] _H
;; + [V3] req/make-component <comp 2> (_I)
;; + [V4] _I

;; XXX
;; Leave this be until we determine if request contexts make sense and work.
;; XXX



;; + [V5] req/attach :pre <actor 1> <comp 1> (_J0)
;; + [V6] _J0
;; + [V7] req/attach :pre <actor 1> <comp 2> (_K0)
;; + [V8] _K0

;; + [V5] req/attach v:bind <actor 1> <comp 1> ()
;; + [V7] req/attach v:bind <actor 1> <comp 2> ()

;; + [V5] req/attach :default <actor 1> <comp 1> (_J1)
;; + [V6] _J1
;; + [V7] req/attach :default <actor 1> <comp 2> (_K1)
;; + [V8] _K1

;; + [V5] req/attach :post <actor 1> <comp 1> (_J2)
;; + [V6] _J2
;; + [V7] req/attach :post <actor 1> <comp 2> (_K2)
;; + [V8] _K2





;; + [V9] req/make-actor <actor 2> () <- This means cannot generate BR requests!
;; + [V10] req/make-component <comp 3> (_L)
;; + [V11] _L
;; + [V12] req/make-component <comp 4> (_M)
;; + [V13] _M
;; + [V14] req/attach <actor 2> <comp 3> (_N)
;; + [V15] _N
;; + [V16] req/attach <actor 2> <comp 4> (_O)
;; + [V17] _O

;; + [V18] req/reparent <actor 2> <actor 1>

;; + [V19] req/spawn-actor <actor 1> <parent 1> (_P)
;; + [V20] _P

;; [X1] _C
;; [X2] req/enable <actor 0> (_D)
;; [X3] _D
;; [X4] req/disable <actor 0> (_E)
;; [X5] _E
;; [W0] req/make-component <comp 0> (_F)
;; [W1] _F
;; [W2] req/attach <actor 0 | comp 0> (_G)
;; [W3] _G
;; [Y5] _A
;; [Y6] req/recompilations (_B)
;; [Y7] _B
;; [00] _
;; HORIZON


;; -----------------------------------------------
;; update
;; _prefab
;; op/make-prefab A ;; start of domain F
;; op/make-prefab B
;; op/make-prefab C ;; end of domain F
;; pre/default/post for multiple bundles in domain F <-
;; move nursery to garden
;; op/enable B
;; op/disable B
;; domain G
;; op/make-prefabs ....
;; domain G
;; _continuation

;; Notes about the op/prolog operation:
;; This particular operation will set up a nursery, cursors, etc, such that if
;; the user creates multiple actors and components they are all considered to be
;; in the SAME domain for the purposes of bundle and future operation execution.
;; After the user prologue function completes, then the operations execute on
;; the "prologue domain"--so across all actors and components in that domain
;; as a whole, as much as possible.


;; If v:enable is a macro that generates

;; (defmethod update ((self ...))
;;  (make-component 'foobar
;;                (lambda (foobar)
;;                  (setf (thingy foobar) self))))

;;(funcall (v:enable compl
;;         function-body))

;; Domains:
;;

;; NOTE: Cursors when inserted are kept in order in a secondary data data
;; struture.



;; -----------------------------------------------------------------------
;; Random testing code.

;; NOTICE: An operation has a scope about who it is going to affect (an actor
;; and it components and it descendants recursively (in typedag order) OR *all*
;; components in typedag order) _and_ operations are themselves ordered.




;; -----------------------------------------------------------------------


;; Next time:
;; Fully understand, Concretize, and Implement the entailment-tree.
;;   See if one entailment-tree or one per type makes a difference in size of
;;   them, number of cookies, etc, etc.

;; Complete nursery and >>> component sorting <<<.
;; Implement bundle definition and storage and execution.
;; Implement attach/detach
;; Implement reparent
;; Implement enable/disable
;; Simulate make-prefab first and the nursery.
;; Don't forget about adding maximum mutation phase limit.
;;
;; Complete understanding of destroy operation.
;; Explore enter/exit events with the bundle system.

;; Implement lambda operation and lambda closures for operations.
;; Possibly merge v:enable and v:enable-register in a better way.
;;
;; Actually emulate component/actor system.
;; Resolve the cursor-context and frame-cursors _key_ API. Should the
;; cursor-context be more ornate?
;; Implement a bundle with sorting on the phases.
;; Define the semantics and concrete understanding of _Domains_.
;; ENsure ordering between operations is what we believe we need.
;;
;; <psilord> Wow! I just realized we can build a gdb like interface for
;;        quack. Like, you can next over an operation, or step into one and
;;        watch it call the bundles on all the components, etc, etc,
;;        etc. "break on any phase emitting an disable" "break when attempting
;;        to enable >this< actor.   [01:09]
;;
;; <psilord> Theoretically, we can have an honest to god interrupt vector
;;        specification. Like, if ops failed to execute (in a BAD way), then
;;        call this user function that isn't a part of any actor or component.
;;                                                                      [01:12]
;; possibly merge some of this together.


;; Tentative Bundle and behavior specifications
;;
;; (v:define-bundle :enable
;;    ((:register (:network :audio :collision))
;;     :pre
;;     :default
;;     (thingy ())
;;     :post))
;;
;;(v:define-bundle :disable
;;    (:pre
;;     :default
;;     :post
;;     (:deregister (:collision :audio :network))))
;;
;;(v:define-bundle foobar
;;    (:pre
;;     :default
;;     :post
;;     (qux (:default))))
;;
;; user writes on their component.
;;(v:define-behavior :enable (:register :collision) ((self comp-type))
;;  nil)
;;
;;(v:define-behavior :enable (thingy) ((self comp-type))
;;  nil)
;;
;;(v:define-behavior :enable :default ((self comp-type))
;;  nil)
;;
;;(v:define-behavior foobar (qux :default) ((self comp-type))
;;  nil)
;;
;; user defined bundle for their own game.
;;(define-bundle-order foo:thingy
;;    (:pre :default :post))


;; This fucking works!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;; vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

;; i is the serial number, T is the lexographic type name (sort order from
;; MOP?)[of the component]!

;; root path one
;; sorting-class SBase         ->   B B B B B B B T| |i|
;; sorting-class Bar (SBase)   ->   r B B B B B B T| |i|
;; sorting-class Qux (Bar)     ->   r B B B B B q T| |i|
;; sorting-class Feh (Qux)     ->   r B d B B B q T| |i|
;; sorting-class Sme (Feh)     ->   r B d B B a q T| |i|


;; root path two
;; sorting-class xxx (SBase)   ->   B B B B u B B T| |i|
;; sorting-class yyy (Feh xxx) ->   r e d p u a q T| |i|
;; sorting-class zzz (SBase)   ->   B B B B B B B T| |i|
;; sorting-class aaa (SBase)   ->   B B B B B B B T| |i|
;; sorting-class bbb (SBase)   ->   B B B B B B B T| |i|

;; (defcomp A (SBase) ...)
;; (defcomp B (SBase aaa) ...)

;; (defcomp render (Bar) ...)
;; (defcomp my-render (Qux) ...)
;; (defcomp my-group-render (Feh) ...)

;; r := :background :player :foreground
;; q := :torso :head :leg :arm

;; render          -> r     T i
;; my-render       -> r   q T i
;; my-group-render -> r d q T i

;; typedag := (... -> (all render) (all foobar) -> ...)

;; r0    -> :background <render> <0>)
;; r1    -> :player <render> <10>)
;; r2    -> :foreground <render> <100>)
;; mr1   -> :player :torso <my-render> <1>)
;; mr2   -> :player :head <my-render> <2>)
;; mr3   -> :player :arm <my-render> <11>)
;; mr4   -> :player :leg <my-render> <18>)
;; mr5   -> :player :leg <my-render> <431>)
;; mr6   -> :player :arm <my-render> <1932>)
;; mgr1  -> :player 1 :torso <my-group-render> <101>)
;; mgr2  -> :player 1 :head <my-group-render> <982>)
;; mgr3  -> :player 1 :arm <my-group-render> <34>)
;; mgr4  -> :player 1 :leg <my-group-render> <345>)
;; mgr5  -> :player 1 :leg <my-group-render> <35>)
;; mgr6  -> :player 1 :arm <my-group-render> <43>)
;; mgr7  -> :background 3 :torso <my-group-render> <1101>)
;; mgr8  -> :background 3 :head <my-group-render> <1982>)
;; mgr9  -> :background 3 :arm <my-group-render> <134>)
;; mgr10 -> :background 3 :leg <my-group-render> <1345>)
;; mgr11 -> :background 3 :leg <my-group-render> <135>)
;; mgr12 -> :background 3 :arm <my-group-render> <143>)
;;
;; ordering
;; sorting-class Bar (SBase)   ->   r B B B B B B T| |i|
;; sorting-class Qux (Bar)     ->   r B B B B B q T| |i|
;; sorting-class Feh (Qux)     ->   r B d B B B q T| |i|

;; order test left column of original order was lost, sorry.
;;
;; :background  d       q
;; mgr7         r0      r0
;; mgr8         mgr7    mgr7
;; r0           mgr8    mgr8
;; mgr9         mgr9    mgr10
;; mgr12        mgr12   mgr11
;; mgr11        mgr11   mgr9
;; mgr10        mgr10   mgr12
;;
;; :player      d       q
;; r1           r1      r1
;; mgr1         mr4     mr1
;; mr4          mr5     mr2
;; mr5          mr1     mr4
;; mgr4         mr2     mr5
;; mgr5         mr3     mr3
;; mr1          mr6     mr6
;; mr2          mgr1    mgr1
;; mgr2         mgr4    mgr2
;; mgr3         mgr5    mgr4
;; mr3          mgr2    mgr5
;; mgr6         mgr3    mgr3
;; mr6          mgr6    mgr6
;;
;; :forground   d       q
;; r2           r2      r2
;;
;;
;; ;; some notes
;;
;; FOO
;; F0 = (:player B <id>)
;; F1 = (:player B <id>)
;;
;; QUX
;; C0  = (:player 0 :leg <id>)   3 i+K
;; C1  = (:player 0 :arm <id>)   5 i+X
;; C2  = (:player 0 :arm <id>)   5 i+Y
;; C3  = (:player 0 :torso <id>) 2
;; C4  = (:player 0 :leg <id>)   4 i+J
;; C5  = ):player 0 :head <id>)  3
;;
;; C6  = (:player 1 :leg <id>)   3 i+K
;; C7  = (:player 1 :arm <id>)   5 i+X
;; C8  = (:player 1 :arm <id>)   5 i+Y
;; C9  = (:player 1 :torso <id>) 2
;; C10 = (:player 1 :leg <id>)   4 i+J
;; C11 = ):player 1 :head <id>)  3
;;
;; D6 = (:background 3 :torso <id>) 0
;; D7 = (:background 3 :head <id>)   1
;;
;;
;;
;; D6
;; D7
;; F0
;; F1
;; C0 - C5




;; A specific edge case from above, but new example sorting types.

;;                  SBase
;;                   |   \
;;                  Feh    Foo
;;                   \   /   |  \
;;                     Meh   Bar  Qux

;; sorting-class SBase          ->   t i
;; sorting-class Feh (SBase)    ->   R S T L t i
;; sorting-class Foo (SBase)    ->   Z t i
;; sorting-class Bar (Foo)      ->   A Z B C t i
;; sorting-class Qux (Foo)      ->   D E Z F t i
;; sorting-class Meh (Feh Foo)  ->   R S T H Z L t i



;; Example Linearization 1
;; sorting-class SBase          ->                             t i
;; sorting-class Feh (SBase)    ->   R S T            L        t i
;; sorting-class Foo (SBase)    ->                  Z          t i
;; sorting-class Bar (Foo)      ->                A Z     B C  t i
;; sorting-class Qux (Foo)      ->            D E   Z   F      t i
;; sorting-class Meh (Feh Foo)  ->   R S T H        Z L        t i
;; TOTAL ORDER
;; sorting-class SBase          ->                             t i
;; sorting-class Foo (SBase)    ->                  Z          t i
;; sorting-class Bar (Foo)      ->                A Z     B C  t i
;; sorting-class Qux (Foo)      ->            D E   Z   F      t i
;; sorting-class Feh (SBase)    ->   R S T            L        t i
;; sorting-class Meh (Feh Foo)  ->   R S T H        Z L        t i



;; Example Linearization 2
;; sorting-class SBase          ->                                  t i
;; sorting-class Feh (SBase)    ->        R S T            L        t i
;; sorting-class Foo (SBase)    ->                       Z          t i
;; sorting-class Bar (Foo)      ->                     A Z     B C  t i
;; sorting-class Qux (Foo)      ->   D E                 Z   F      t i
;; sorting-class Meh (Feh Foo)  ->        R S T H        Z L        t i
;; TOTAL ORDER
;; sorting-class SBase          ->                                  t i
;; sorting-class Foo (SBase)    ->                       Z          t i
;; sorting-class Bar (Foo)      ->                     A Z     B C  t i
;; sorting-class Feh (SBase)    ->        R S T            L        t i
;; sorting-class Meh (Feh Foo)  ->        R S T H        Z L        t i
;; sorting-class Qux (Foo)      ->   D E                 Z   F      t i


;; sorting-class SBase          ->                           p i
;; sorting-class Foo (SBase)    ->                 Z         p i
;; sorting-class Qux (Foo)      ->             D E Z F       p i
;; sorting-class Feh (SBase)    ->     R S T           L     p i
;; sorting-class Meh (Feh Foo)  ->     R S T H     Z   L     p i
;; sorting-class Bar (Foo)      ->   A             Z     B C p i


;; breadth first
;;                                   R D S A E T H Z B F C L P I
;; sorting-class SBase          ->                           p i
;; sorting-class Foo (SBase)    ->                 Z         p i
;; sorting-class Bar (Foo)      ->         A       Z B   C   p i
;; sorting-class Qux (Foo)      ->     D     E     Z   F     p i
;; sorting-class Feh (SBase)    ->   R   S     T           L p i
;; sorting-class Meh (Feh Foo)  ->   R   S     T H Z       L p i

;; depth first
;;                                   D E R S T H A Z B C F L P I

;; sorting-class SBase          ->                           p i
;; sorting-class Foo (SBase)    ->                 Z         p i
;; sorting-class Bar (Foo)      ->               A Z B C     p i
;; sorting-class Feh (SBase)    ->       R S T             L p i
;; sorting-class Meh (Feh Foo)  ->       R S T H   Z       L p i
;; sorting-class Qux (Foo)      ->   D E           Z     F   p i

;; (sorting-class-name (columns))

;;#((MEH   (R S T H Z L P I))
;;  (BAR   (    A Z B C P I))
;;  (FEH   (    R S T L P I))
;;  (QUX   (    D E Z F P I))
;;  (FOO   (          Z P I))
;;  (SBASE (            P I)))

;; I   P   L   C   F   Z   B   T   H   S   E   A   R   D
;; 0   1   2   3   4   6   5   8   7  11   9  10  13  12

;; column order. I is in column 0
;; 13 12 11 10 9 8 7 6 5 4 3 2 1 0
;;  R  D  S  A E T H Z B F C L P I

;; edge-table
;; XXX -> YYY    means "XXX is to the right of YYY"
;; I_0 -> P_1
;; P_1 -> L_2 C_3 F_4 Z_6 NIL
;; L_2 -> Z_6 T_8
;; C_3 -> B_5
;; F_4 -> Z_6
;; Z_6 -> NIL H_7 E_9 A_10
;; B_5 -> Z_6
;; T_8 -> S_11
;; H_7 -> T_8
;; S_11 -> R_13
;; E_9 -> D_12
;; A_10 -> NIL
;; R_13 -> NIL
;; D_12 -> NIL

;;edge table
;; XXX -> YYY    means "XXX is to the left of YYY"
;; P_1 -> I_0
;; L_2 -> P_1
;; C_3 -> P_1
;; F_4 -> P_1
;; Z_6 -> P_1 L_2 F_4 B_5
;; NIL -> P_1 Z_6 A_10 R_13 D_12
;; B_5 -> C_3
;; T_8 -> L_2 H_7
;; H_7 -> Z_6
;; S_11 -> T_8
;; E_9 -> Z_6
;; A_10 -> Z_6
;; R_13 -> S_11
;; D_12 -> E_9


;; 3b's idea of depth first assignment.
;;edge table
;; XXX -> YYY    means "XXX is to the left of YYY"
;; P_1 -> I_0
;; L_2 -> P_1
;; C_4 -> P_1
;; F_3 -> P_1
;; Z_6 -> P_1 L_2 F_3 B_5
;; NIL -> P_1 Z_6 A_7 R_11 D_13
;; B_5 -> C_4
;; T_9 -> L_2 H_8
;; H_8 -> Z_6
;; S_10 -> T_9
;; E_12 -> Z_6
;; A_7 -> Z_6
;; R_11 -> S_10
;; D_13 -> E_12

;; 13 12 11 10 9 8 7 6 5 4 3 2 1 0
;;  D  E  R  S T H A Z B C F L P I

;; ensure assertions about edge table consistency in both tables are correct.

(defun stats (shash edge-table col-assignment)
  (let ((total-columns (hash-table-count shash)))
    (format t "number of columns: ~A~%" total-columns)

    (u:do-hash (col cnt shash)
      (format t "Column: ~(~S~) : ~D~%" col cnt))

    (format t "Edge-list:~%~{ ~A~%~}"  (u:hash->alist edge-table))

    (format t "column assignments :~%~{ ~A~%~}"
            (sort (u:hash->alist col-assignment) #'< :key #'cdr))

    ))

(defun linearize (db)
  (let ((db (copy-tree db))
        (total-columns 0)
        (shash (u:dict #'eq)))
    ;; 1. Compute total number of columns & column frequency(?)
    (loop :for (sc cols) :in db
          :do (loop :for col :in cols
                    :do (u:ensure-gethash col shash 0)
                        (incf (u:href shash col))))
    (setf total-columns (hash-table-count shash))

    ;; 2. Sort sorting class by 1) number of columns, then 2) lexical type
    (let ((db (sort db (lambda (left right)
                         (destructuring-bind (lname lcols) left
                           (destructuring-bind (rname rcols) right
                             (cond
                               ((= (length lcols) (length rcols))
                                (string< lname rname))

                               ((> (length lcols) (length rcols))
                                T)

                               (t
                                nil))))))))

      ;;(format t "db =~%~{~A~%~}" db)

      ;; 3a. Assemble the edge table.
      ;; Here we construct a "LEFT is to the left of RIGHT" table
      (let ((rev-cols (map 'vector (lambda (x) (reverse (second x))) db))
            (edge-table (u:dict #'eq)))
        ;;(:printv rev-cols)
        (u:while (notevery #'null rev-cols)
          (loop :for idx :below (length rev-cols)
                :when (aref rev-cols idx)
                  :do
                     (let ((right (pop (aref rev-cols idx)))
                           (left (first (aref rev-cols idx))))
                       (pushnew right (u:href edge-table left) :test #'eq))))

        ;; 3b. Reverse the edge-table value lists.
        (u:do-hash-keys (key edge-table)
          (u:reversef (u:href edge-table key)))


        ;; 4. Mark the nodes with a column number in a depth first search of
        ;; the edge table. We stop searching when we hit a node that contains
        ;; a column number and assign a increasing number on the way out.
        ;; Also stop recursing when we find a node that is not in the table,
        ;; which means it is a root node. NOTE: There should be only ONE root
        ;; node in our sorting mixing use case. The root node should always
        ;; be the serial-number for the sorting system.
        (let ((col-assignment (u:dict #'eq))
              (last-assigned-col-number 0))
          (labels ((get-col-number ()
                     (prog1 last-assigned-col-number
                       (incf last-assigned-col-number)))

                   (mark (node)

                     ;; base case.
                     (when (integerp (u:href col-assignment node))
                       (return-from mark))


                     (let ((rights (u:href edge-table node)))
                       (dolist (right rights)
                         (mark right))

                       (when node
                         (setf (u:href col-assignment node)
                               (get-col-number))

                         ;; assert that we've built a sound tree.
                         (dolist (right rights)
                           ;; TODO: If this fails, ensure to print out the
                           ;; whole of the test case so we can find out why.
                           (assert (> (u:href col-assignment node)
                                      (u:href col-assignment right))))))))

            (mark nil)

            #++(stats shash edge-table col-assignment)

            ;; We treat column zero as being on the RIGHT side of the table.
            (sort (u:hash->alist col-assignment) #'> :key #'cdr)

            ))))))

;; TODO: add this
(defun make-partition (m n)
  (let ((p (make-array m :initial-element nil)))
    (loop :for i :below n
          :do (push i (aref p (random m))))
    ;; TODO: Fix later.
    (coerce p 'list)))

(defun gen-name (table)
  (let ((name (string-upcase
               (u:random-elt net.mfiano.lisp.algae.rng::+dictionary+))))
    (if (u:href table name)
        (gen-name table)
        (let ((sym (make-symbol name)))
          (setf (u:href table name) t)
          sym))))



(defun select-columns (edges partition node-count bit-positions)
  (let ((node-bits (coerce (loop :repeat node-count
                                 :collect (make-array (length bit-positions)
                                                      :element-type 'bit
                                                      :initial-element 0))
                           'vector))
        (parents (make-array node-count :initial-element nil)))
    (loop for i below node-count
          for bits = (pop partition)
          for children = (gethash i edges)
          do (loop for b in bits do (setf (aref (aref node-bits i) b) 1))
             (loop for c in children
                   do (setf (aref node-bits c)
                            (bit-ior (aref node-bits i)
                                     (aref node-bits c)))
                      (push i (aref parents c))))

    (map 'list (lambda (x y)
                 (list y (bitvector->bit-ordering x bit-positions)))
         node-bits parents)))

(defun bitvector->bit-ordering (bitvector list)
  (loop :with v = (coerce list 'vector)
        :for b :across bitvector
        :for i :from 0
        :when (plusp b)
          :collect (aref v i)))


(defun gen-db (node-count column-count)
  (let* ((words (u:dict #'equal))
         (bit-positions (u:iota column-count))
         (bit-partition (make-partition node-count column-count))
         (class-names (coerce (loop :repeat node-count
                                    :collect (gen-name words))
                              'vector))
         (column-names (coerce (loop :repeat column-count
                                     :collect (gen-name words))
                               'vector)))

    (labels ((gen-dag (node-num)
               (let ((edges (u:dict #'eql)))
                 (loop :for source :from 1 :below node-num
                       :do (loop :repeat (1+ (random 10))
                                 :for target = (random source)
                                 :do (pushnew source (u:href edges target))))
                 edges)))

      ;; Returns bit vector indexed at integer node
      (let ((columns-per-node (select-columns (gen-dag node-count)
                                              bit-partition
                                              node-count
                                              bit-positions)))
        (loop :for (parents cols) :in columns-per-node
              :for i :from 0
              :collect (list (aref class-names i)
                             (loop :for p :in parents
                                   :collect (aref class-names p))
                             (loop :for c :in cols
                                   :collect (aref column-names c))))))))

(defun doit3 (&optional (node-count 3) (column-count 3) (verbose nil))
  (let* ((raw-db (mapcar (lambda (x)
                           (list (first x) (second x)
                                 (append (third x) '(p i))))
                         (gen-db node-count column-count)))
         #++(raw-db '((sbase () (p i))
                      (foo (sbase) (z p i))
                      (qux (foo) (d e z f p i))
                      (feh (sbase) (r s k l p i))
                      (meh (feh foo) (r s k h z l p i))
                      (bar (foo) (a z b c p i))))
         (all-columns (remove-duplicates
                       (u:flatten (mapcar #'third raw-db))))
         (db (mapcar (lambda (x)
                       (list (first x) (third x)))
                     raw-db))
         )

    (and (rule-db/sorting-class-syntactically-well-formed raw-db)

         )

    (let ((linearization (linearize db)))

      (when verbose
        (format t "There are ~a named columns.~%" (length all-columns))
        (format t "*** db:~%~{~A~%~}--> linearization:~%~{~A~%~}"
                raw-db linearization))

      ;; Typecheck
      (unless (or (rule-lin/no-duplicated-columns linearization)
                  (rule-lin/no-duplicated-indices linearization)
                  (rule-lin/only-valid-columns-exist linearization all-columns)
                  (rule-lin/sorting-class-column-order-preserved linearization
                                                                 raw-db)
                  (rule-lin/no-index-holes-start-from-zero linearization))

        (error "Linearization typecheck failed."))

      linearization)))

;;;; Raw-db type rules.
(defun rule-db/sorting-class-syntactically-well-formed (raw-db)
  (unless (listp raw-db)
    (error "raw-db is not a list"))

  (labels ((invalid-symbol (item)
             ;; a symbol that cannot be a certain subset of symbols.
             (and (symbolp item)
                  (or (keywordp item)
                      (eq item nil)
                      (eq item t))))

           (process-sorting-class (spec)
             (unless (listp spec)
               (error "spec is not a list"))

             (destructuring-bind (&optional sc parents cols) spec
               (when (invalid-symbol sc)
                 (error "spec name is not a valid symbol"))
               (unless (listp parents)
                 (error "spec parents is not a cons"))
               (unless (consp cols)
                 (error "spec columns is not a cons"))

               (dolist (parent parents)
                 (when (not (symbolp parent))
                   (error "spec parent is not a symbol"))
                 (when (invalid-symbol parent)
                   (error "spec parent is not a valid symbol")))

               (dolist (col cols)
                 (cond
                   ((symbolp col)
                    (when (invalid-symbol col)
                      (error "spec col is not a proper symbol.")))
                   ((consp col)
                    (destructuring-bind (&optional col-name . comparator) col
                      (when (invalid-symbol col-name)
                        (error "spec col name in compound form is wrong."))
                      (cond
                        ((= (length comparator) 1)
                         (when (invalid-symbol (first comparator))
                           (error "spec col comparator is invalid."))
                         t)
                        (t
                         (error "spec col compound form is invalid."))))))))))

    (dolist (spec raw-db)
      (process-sorting-class spec))))

;;;; linearization type rules.
(defun rule-lin/no-duplicated-columns (linearization)
  (= (length linearization)
     (length (remove-duplicates linearization :key #'car))))

(defun rule-lin/no-duplicated-indices (linearization)
  (= (length linearization)
     (length (remove-duplicates linearization :key #'cdr))))

(defun rule-lin/only-valid-columns-exist (linearization all-columns)
  (and (null (set-difference (mapcar #'first linearization) all-columns))
       (= (length linearization) (length all-columns))))

(defun rule-lin/sorting-class-column-order-preserved (linearization raw-db)
  (let ((x (loop :for (name parents columns) :in raw-db
                 :collect (mapcar (lambda (col)
                                    (cdr (assoc col linearization)))
                                  columns))))
    (every (lambda (col-indices)
             (apply #'> col-indices))
           x)))

(defun rule-lin/no-index-holes-start-from-zero (linearization)
  (equal (mapcar #'cdr (sort (copy-seq linearization) #'< :key #'cdr))
         (u:iota (length linearization))))


(defun doit4 (&optional (n 128))
  (loop :for i :below n
        :do (when (zerop (mod i 1024))
              (format t ".")
              (finish-output))
            (doit3 (+ 5 (random 5)) (+ 10 (random 10))))
  (format t "~%"))

;; External validation

;; NOTE: Once an ordering between two columns has been defined, that order must
;; be true for ALL sorting classes everywhere that use those two columns.
;; If any derived sorting class has a conflicting order for two sorting
;; columns, it is an error.

;;;; raw-db validation pass:

;; [x] rule-db/sorting-class-syntactically-well-formed
;;     <acts upon a single sorting-class form>
;; Each sorting class must have a
;;  name: a single symbol
;;  parents: a list of symbols, null is ok, but not as a parent member.
;;  columns: a list of items which are a single symbol or (symbol symbol)
;;  NOTE: the (sym1 sym2) form means sym2 is a runtime looked up function
;;        symbol. This means we disallow (f #'f) since it turns into
;;        (f (function f)). We also believe that a fixed function specified
;;        with FUNCTION leads to a case where if the user redefines that
;;        function at runtime, it will NOT update the sorting class, and will
;;        lead to confusion. We (the devs) can optimize looking up the function
;;        ourselves at the end of a frame if we need to speed it up, etc.

;; [ ] rule-db/no-forward-parent-declarations
;;     <acts upon a the full raw-db of sorting-class forms>
;;     A raw-db sorting-class cannot use a parent sorting-class which
;;     hasn't been seen before.

;; [ ] rule-db/column-definitions-and-references-well-formed
;;     <acts upon a the full raw-db of sorting-class forms>
;;     When a column is first defined in a sorting class hierarchy, it REQUIRES
;;     a comparator function to be paired with it. It can only be defined once.
;;
;;     When a column previously defined in the sorting hierarchy is referenced,
;;     it MUST NOT supply a comparator function.

;; [ ] rule-db/canonicalize-for-linearization
;;     Canonicalize the raw-db to remove the column sorting function names.
;;     It strictly means removing the function comparators and making the
;;     columns a pure symbol name.

;; [ ] rule-db/valid-column-inheritance
;;     Ensure that all columns in a particular raw-db came from either itself,
;;     or some parent in the hierarchy.

;; [ ] rule-db/no-duplicate-parents
;;     Each of the sorting class parents must be unique in the parent list.
;;     No NIL/T, or keywords, in the parents list.

;; [ ] rule-db/sorting-class-unique
;;     Each sorting class name in a raw-db must be a unique name.
;;     Duplicate column names that are in different packages are allowed.

;; [ ] rule-db/all-column-pairs-preserve-order
;;     All pairs of columns for each sorting-class must preserve their
;;     order in all classes that used those columns.

;; And then, if all the above passes, we can pass it to LINEARIZE.

;;;; linearization validation pass:

;; [x] rule-lin/no-duplicated-columns
;;     No duplicated column names in linearization.

;; [x] rule-lin/no-duplicated-indices
;;     No duplicated column indices in linearization.

;; [x] rule-lin/only-valid-columns-exist
;;     All columns in each sorting-class must exist in the final ordering.
;;     No extra columns, no missing columns.

;; [x] rule-lin/sorting-class-column-order-preserved
;;     The order of each sorting-class column must be preserved in the
;;     linearization.

;; [x] rule-lin/no-index-holes-start-from-zero
;;     No holes in the integer indexing starting from 0 to max column number.


;;;; Guidelines & Other stuff to do

;; Include hardcoded specific and interesting test cases like diamond dags
;; or complex ones we think are interesting.

;; Include first real uses of this system (in V) as actual test cases.

;; Add a unit test for each code path for these type checks. Use Prove.






#|

(define-sorting-classes name ()
(sbase () ((p component-type<) (i '<))) -> (sbase () (p i))
(integer-order (sbase) ((v '<) p i)))   -> (integer-order (sbase) (v p i))

(define-sorting-classes name ()
(foo (integer-order) ((x '>) v p i)))

|#
